#JVM 内存区域

## 前言 ##
java虚拟机在管理的内存包括：**程序计数器、虚拟机栈、本地方法栈、方法区、堆、运行时常量池、直接内存**。

## 一、程序计数器 
 
   1、是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器。

   2、字节码解释器就是通过改变这个计数器来执行下一条指令，例如循环、跳转、异常处理等都需要通过这个计数器来完成。
   
   3、是**线程私有**的。生命周期与线程相同，每条线程都拥有一个，独立存储。
	
   4、如果执行的是一个**java**方法，计数器记录的是正在执行的**虚拟机字节码指令地址；**如果执行的是一个**Native**方法，计数器存储的值为空。
   
   5、这个区域是**唯一一个**在虚拟机规范里没有规定任何OutOfMenoryError情况的区域。

## 二、虚拟机栈 ##
   1、**线程私有**，生命周期与线程相同。
   
   2、每个方法在执行的时候会**创建栈帧**，执行的过程**相当于进栈出栈的过程**。
	
   3、栈帧用于存储：**局部变量表、操作数栈、动态链表、方法出口**等信息。

   4、如果线程请求的栈深度大于虚拟机所允许的深度，将抛出**StackOverflowError**异常。

   5、在虚拟机栈允许扩展的情况下，在扩展时无法申请到足够的内存，将会抛出**OutOfMemoryError**异常。

## 三、本地方法栈
   1、本地方法栈为虚拟机用到的Native方法服务。
	
   2、本地方法栈使用的语言、使用方式与数据结构并没有强制规定。
   
   3、会抛出**StackOverflowError**异常和**OutOfMemoryError**异常。

## 四、Java堆
   1、java堆是被线程共享的，在虚拟机启动时创建。

   2、主要作用是为了存放对象。
   
   3、从内存回收的角度来看，基本采用**分代收集算法**，可以分为：**新生代，老年代** ；细分可以分为**Eden空间，From Survivor空间，To Survivor空间**。
   
   4、从内存分配的角度，线程共享中可能划分出多个线程私有的**分配缓冲区** （TLAB）。  

   5、java堆可以处于物理上不连续的内存空间，只要逻辑上是连续的即可。

   6、如果在堆中没有内存完成实例分配，并且堆也无法扩展是，将会抛出**OutOfMemoryError**异常。

## 五、方法区

1、方法区是线程共享的，用于存储已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。

2、这个区域的内存回收的主要目标是针对常量池的回收和对类型的卸载。

3、当无法满足内存分配需求时，会抛出**OutOfMemoryError**异常。

## 六、运行时常量池

1、是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是**常量池**，用于**存放编译期生成的各种字面量和符号引用**，这部分内容将在类加载后进入方法区的运行时常量池存放。

2、还会将翻译出来的直接引用也存储到运行时常量池中。

3、当常量池无法申请到内存时会抛出**OutOfMemoryError**异常。

## 七、直接内存
1、直接内存并不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。

2、NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库**直接分配堆外内存**，然后通过一个存储在Java堆中的DirectByBuffer对象作为这块内存的引用进行操作。能在某些场景中显著提高性能因为避免java堆和Native堆中来回复制数据。  