## 一、 GC
可达性分析必须确保一致性，所以要在发生GC时，系统会进行暂停。
由于现在的虚拟机是执行准确性GC，在虚拟机中就使用OopMap数据结构来存放指令中执行上下文和全局性引用的信息，来确保快速准确地扫描。

同时虚拟机也没有为每条指令创建OopMap，而是在某些特定的位置上记录信息，这些位置被称为安全点。
安全点的选取是根据“是否让程序具有长时间执行的特征”，例如：方法调用，循环跳转，异常跳转等。
同时安全点也是GC中断线程的标志，因为现在的虚拟机大多采用的是主动式中断的方法进行GC中断。 
主动式中断：不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行时主动去轮询这个标志，发现中断标志为真时就中断挂起。
            标志位：是安全点的位置和创建对象需要分配内存的地方。
			
当程序没有分配到CPU时间的时候，就需要安全区域来解决GC的问题。
安全区域：是指在一段代码片段中，引用关系不会发生变化。在这个区域中的任意地方发生GC都是安全的。 
       当线程执行到安全区中的代码时，首先标识自己已经进入安全区，当线程要离开安全区时，线程会检查系统已经完成里根节点枚举（或者是GC过程），
	   如果完成了，那线程就继续执行，否则他就必须等待直到收到可以安全离开安全区的信息为止。

##二、jvm 垃圾收集器	
> 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户；</br>
> 高吞吐量则可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多的交互任务。   
	   
###1、Serial收集器
	
  1）Serial收集器是一个**单线程收集器**，只使用一个CPU或者一条线程来完成垃圾回收，在执行垃圾回收时，会将**用户所有的线程暂停**（Stop the world），直到垃圾回收完成。
	
  2）Serial收集器具有**简单高效**的特点，对于限定单个CPU的环境来说，Serial收集器没有了与其他线程交互的开销，专心做垃圾收集来获取最高的回收效率。
	
  3）回收策略：新生代：复制算法；老年代：标记整理算法

###2、ParNew收集器
    
  1）ParNew收集器是一个**多线程收集器**，是**Serial收集器的多线程版本**。

  2）ParNew收集器除了使用多线程收集，其他的行为与Serial收集器基本相同，包括可用的控制参数，收集算法，Stop the world，对象分配策略，回收策略。

  3）ParNew是很多运行在Server模式下的虚拟机的首选，因为**只有它才可以与CMS虚拟机配合。**

### 3、Parallel Scavenge 收集器
    
  1）Parallel Scavenge 收集器是一个新生代收集器，使用复制算法的多线程收集器。

  2）Parallel Scavenge 收集器的目标是**达到一个可控制的吞吐量**。

   3）吞吐量：CPU用于运行用户代码的时间与CPU总消耗时间的比值。

	吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间 )

