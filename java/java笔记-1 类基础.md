# 类的基础
<!-- TOC -->

- [类的基础](#类的基础)
    - [类的组成](#类的组成)
        - [类变量](#类变量)
        - [类函数](#类函数)
        - [实例变量](#实例变量)
        - [实例方法](#实例方法)
        - [构造函数](#构造函数)
    - [程序的编译和链接](#程序的编译和链接)
        - [编译](#编译)
        - [链接](#链接)
    - [类和对象的生命周期](#类和对象的生命周期)

<!-- /TOC -->
--------------------------
## 类的组成  
--------------------------
>类在大多数情况下被看做是函数的容器，但更多的是表示自定义数据类型。  
>若将类看做是数据类型的话，则是由包含的属性以及该类型可以进行的操作组成。

一个简单的类是由5部分组成：  
>1、初始化类时使用的构造函数  
>2、类型本身包含的属性，通过类变量实现  
>3、类型本身包含的操作，通过类函数实现  
>4、实例包含的属性，通过实例变量实现  
>5、实例包含的操作，通过实例函数实现
```java
public class Test(){
  private int a;
  private int b;

  public static final c = 123;

  public Test(){}

  public Test(a,b){
    this.a = a;
    this.b = b;
  }

  public void show(){
    System.out.println("a:" + a + " " + "b:" + b);
  }
}
```
### 类变量
1、通过类名进行访问。  
2、一般在类加载时只加载一次。  
3、类型前一般由**static**关键字修饰。  
4、经常用于表示常量:
```java
public static final int pi = 3.14;
```

### 类函数
1、通过类名访问。  
2、由**static**关键字修饰。   
3、类方法只能访问类变量，不能访问实例变量，只能调用类方法，不能调用实例方法。  
```java
public static void test(){}
```

### 实例变量  
1、通过对象或者**this**关键字访问。  
2、一般是用**private**关键字修饰，并通过get/set方法来获取和修改。  
```java
  private int a;
```

### 实例方法
1、通过对象或者**this**关键字访问。
```java
public void test(){}
```
---
### 构造函数
1、名字固定  
2、没有返回值  
3、可以重载  
4、可以调用其他构造方法  
5、如果调用其他的构造方法，则必须将被调用的方法放在当前构造函数的第一行。

##程序的编译和链接
> 程序从java代码到运行的程序，要经过编译和链接两个步骤

###编译  
- 编译是将源代码变成一种拓展名为.**class**的字节码文件
- 编译时，编译器会确定引用的每个类的完全限定名，确定的方式是通过**import语句**和**classpath**。  
如果导入的是完全限定名则可以直接比较并确定。  
如果是模糊导入（import带*），则根据classpath来找到父包，在在父包下寻找是否有对应的类。如果模糊导入中出现相同的类名，编译器则会提示编译错误。

>classpath:**类路径**  
>对于直接class文件来说，类路径是class文件的根目录；  
>对于jar包来说，类路径是jar包的完整名称（包括路径和jar包名）

### 链接
- 就是在运行时动态的加载引用到的类的字节码文件并执行。
- java在运行时，会根据类的完全限定名寻找并加载类，寻找的方式就是类路径中寻找。  
如果是jar文件，首先在内存中解压文件，然后在查看是否有对应的类。  
如果是class文件的根目录，则直接查看是否有对应的子目录及文件。
---
##类和对象的生命周期
1、当程序运行时，第一次通过**new**创建一个类的对象时，或者通过类名访问类变量或者是类方法时，java会将类加载进内存，并为类分配一个空间，这个空间包括类的定义、变量和方法信息，同时还有类的静态变量，并对静态变量赋初始值。

2、类在加载进内存后，一般不会释放，直到程序结束。所以静态变量在内存只会有一份。

3、创建对象后会在内存分配两块区域，其中保存地址信息存放在栈中，而存储真正内容的部分存放在堆中。  
栈中的内存是**自动管理**的，当函数入栈时自动分配，函数出栈自动释放。  
堆中的内存是被**垃圾回收机制**管理的，当程序中没有**活动对象**时，对应的堆空间可能会被释放。

>活动对象：就是已加载的类的类变量，以及栈中的变量。

